{"version":3,"sources":["../node_modules/js-cookie/src/js.cookie.js","../src/tunnel.ts","../src/other.ts","../node_modules/hotkeys-js/dist/hotkeys.esm.js","../src/menu.ts","../node_modules/fuse.js/dist/fuse.esm.js","../src/index.ts"],"names":["hotkeys","isff","navigator","userAgent","toLowerCase","indexOf","addEvent","object","event","method","addEventListener","attachEvent","concat","window","getMods","modifier","key","mods","slice","length","i","getKeys","index","keys","replace","split","lastIndexOf","splice","compareArray","a1","a2","arr1","arr2","isIndex","_keyMap","backspace","tab","clear","enter","return","esc","escape","space","left","up","right","down","del","delete","ins","insert","home","end","pageup","pagedown","capslock","_modifier","shift","alt","option","ctrl","control","cmd","command","modifierMap","shiftKey","ctrlKey","altKey","metaKey","_mods","_handlers","k","_downKeys","_scope","elementHasBindEvent","code","x","toUpperCase","charCodeAt","setScope","scope","getScope","getPressedKeyCodes","filter","target","srcElement","tagName","flag","isContentEditable","readOnly","isPressed","keyCode","deleteScope","newScope","handlers","Object","prototype","hasOwnProperty","call","clearModifier","which","charCode","unbind","keysInfo","Array","isArray","forEach","info","eachUnbind","_len","arguments","args","_key","splitKey","_ref","_ref$splitKey","originKey","unbindKeys","len","lastKey","map","record","isMatchingMethod","eventHandler","handler","modifiersMatch","y","shortcut","preventDefault","returnValue","stopPropagation","cancelBubble","dispatch","asterisk","push","keyName","keyNum","e","getModifierState","type","keydown","keyup","_i","keyShortcut","_downKeysCurrent","a","sort","join","isElementBind","element","document","undefined","toString","_api","_hotkeys","noConflict","deep","Fuse","value","getTag","INFINITY","baseToString","result","isString","isNumber","isBoolean","isObjectLike","isObject","isDefined","isBlank","trim","EXTENDED_SEARCH_UNAVAILABLE","INCORRECT_INDEX_TYPE","LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY","PATTERN_LENGTH_TOO_LARGE","max","MISSING_KEY_PROPERTY","name","INVALID_KEY_WEIGHT_VALUE","hasOwn","KeyStore","constructor","_keys","totalWeight","obj","createKey","weight","id","get","keyId","toJSON","JSON","stringify","path","src","createKeyPath","createKeyId","Error","list","arr","deepGet","MatchOptions","includeMatches","findAllMatches","minMatchCharLength","BasicOptions","isCaseSensitive","includeScore","shouldSort","sortFn","b","score","idx","FuzzyOptions","location","threshold","distance","AdvancedOptions","useExtendedSearch","getFn","ignoreLocation","ignoreFieldNorm","Config","SPACE","norm","mantissa","cache","Map","m","Math","pow","numTokens","match","has","sqrt","n","parseFloat","round","set","FuseIndex","isCreated","setIndexRecords","setSources","docs","records","setKeys","_keysMap","create","doc","docIndex","_addString","_addObject","add","size","removeAt","getValueForItemAtKeyId","item","v","$","keyIndex","subRecords","stack","nestedArrIndex","pop","subRecord","createIndex","myIndex","parseIndex","data","computeScore","pattern","errors","currentLocation","expectedLocation","accuracy","proximity","abs","convertMaskToIndices","matchmask","indices","start","MAX_BITS","search","text","patternAlphabet","patternLen","textLen","min","currentThreshold","bestLocation","computeMatches","matchMask","lastBitArr","finalScore","binMax","mask","binMin","binMid","floor","finish","bitArr","j","charMatch","charAt","isMatch","createPatternAlphabet","char","BitapSearch","options","chunks","addChunk","startIndex","alphabet","remainder","substr","searchIn","allIndices","totalScore","hasMatches","BaseMatch","isMultiMatch","getMatch","multiRegex","isSingleMatch","singleRegex","exp","matches","ExactMatch","InverseExactMatch","PrefixExactMatch","startsWith","InversePrefixExactMatch","SuffixExactMatch","endsWith","InverseSuffixExactMatch","FuzzyMatch","_bitapSearch","IncludeMatch","searchers","searchersLen","SPACE_RE","OR_TOKEN","parseQuery","query","results","queryItem","found","searcher","token","MultiMatchSet","Set","ExtendedSearch","condition","_","numMatches","qLen","pLen","registeredSearchers","register","createSearcher","searcherClass","LogicalOperator","AND","OR","KeyType","PATH","PATTERN","isExpression","isPath","isLeaf","convertToExplicit","parse","auto","next","isQueryPath","node","children","operator","computeScore$1","Number","EPSILON","transformMatches","refIndex","transformScore","format","transformers","transformer","_keyStore","setCollection","_docs","_myIndex","remove","predicate","getIndex","limit","_searchStringList","_searchObjectList","_searchLogical","expression","evaluate","_findMatches","res","child","resultMap","expResults","version","config"],"mappings":"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","file":"src.8e50efa0.js","sourceRoot":"../page","sourcesContent":["/*!\n * JavaScript Cookie v2.2.1\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader;\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n}(function () {\n\tfunction extend () {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[ i ];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction decode (s) {\n\t\treturn s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);\n\t}\n\n\tfunction init (converter) {\n\t\tfunction api() {}\n\n\t\tfunction set (key, value, attributes) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tattributes = extend({\n\t\t\t\tpath: '/'\n\t\t\t}, api.defaults, attributes);\n\n\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\tattributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);\n\t\t\t}\n\n\t\t\t// We're using \"expires\" because \"max-age\" is not supported by IE\n\t\t\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n\t\t\ttry {\n\t\t\t\tvar result = JSON.stringify(value);\n\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\tvalue = result;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\n\t\t\tvalue = converter.write ?\n\t\t\t\tconverter.write(value, key) :\n\t\t\t\tencodeURIComponent(String(value))\n\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\n\t\t\tkey = encodeURIComponent(String(key))\n\t\t\t\t.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)\n\t\t\t\t.replace(/[\\(\\)]/g, escape);\n\n\t\t\tvar stringifiedAttributes = '';\n\t\t\tfor (var attributeName in attributes) {\n\t\t\t\tif (!attributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstringifiedAttributes += '; ' + attributeName;\n\t\t\t\tif (attributes[attributeName] === true) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Considers RFC 6265 section 5.2:\n\t\t\t\t// ...\n\t\t\t\t// 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n\t\t\t\t//     character:\n\t\t\t\t// Consume the characters of the unparsed-attributes up to,\n\t\t\t\t// not including, the first %x3B (\";\") character.\n\t\t\t\t// ...\n\t\t\t\tstringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n\t\t\t}\n\n\t\t\treturn (document.cookie = key + '=' + value + stringifiedAttributes);\n\t\t}\n\n\t\tfunction get (key, json) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar jar = {};\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all.\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (!json && cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = decode(parts[0]);\n\t\t\t\t\tcookie = (converter.read || converter)(cookie, name) ||\n\t\t\t\t\t\tdecode(cookie);\n\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tjar[name] = cookie;\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn key ? jar[key] : jar;\n\t\t}\n\n\t\tapi.set = set;\n\t\tapi.get = function (key) {\n\t\t\treturn get(key, false /* read as raw */);\n\t\t};\n\t\tapi.getJSON = function (key) {\n\t\t\treturn get(key, true /* read as json */);\n\t\t};\n\t\tapi.remove = function (key, attributes) {\n\t\t\tset(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.defaults = {};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n}));\n","import * as Cookies from 'js-cookie';\n\nexport const DOMAIN_ROOT = 'https://train.nzoi.org.nz';\nconst ROUTER = 'https://technocoder-cors-bypass.herokuapp.com/';\nconst SESSION_KEY_SECRET = 'session_secret';\n\nexport async function tunnelImage(element: HTMLImageElement) {\n    let response = await fetch(ROUTER + element.src, requestMetadata());\n    if (!response.ok) throw Error(response.statusText);\n    element.src = URL.createObjectURL(response.blob());\n}\n\nexport async function fetchPage(link: string): Promise<Document> {\n    let response = await fetch(ROUTER + link, requestMetadata());\n    if (!response.ok) throw Error(response.statusText);\n\n    let parser = new DOMParser();\n    let data = await response.text();\n    return parser.parseFromString(data, 'text/html');\n}\n\nexport async function postData(link: string, data: FormData) {\n    let metadata = requestMetadata();\n    metadata.method = 'POST';\n    metadata.body = data;\n\n    let response = await fetch(ROUTER + link, metadata);\n    if (!response.ok) throw Error(response.statusText);\n}\n\nexport function setSessionIdentifier(secret: string) {\n    if (secret.trim().length == 0)\n        return Cookies.remove(SESSION_KEY_SECRET);\n    Cookies.set(SESSION_KEY_SECRET, secret);\n}\n\nexport function sessionIdentifier(): string | undefined {\n    return Cookies.get(SESSION_KEY_SECRET);\n}\n\nfunction requestMetadata(): RequestInit {\n    let request: RequestInit = {};\n    let session = sessionIdentifier();\n    if (session == null) return request;\n\n    request.credentials = 'include';\n    request.headers = {'Forward-Cookie': `_session_id=${session}`};\n    return request as RequestInit;\n}\n\n","export function detach(node: Node): Node {\n    return node.parentNode.removeChild(node);\n}\n\nexport function template(template: Element): Element {\n    let node = template as HTMLTemplateElement;\n    return node.content.cloneNode(true) as Element;\n}\n","/*!\n * hotkeys-js v3.8.1\n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.\n * \n * Copyright (c) 2020 kenny wong <wowohoo@qq.com>\n * http://jaywcjlove.github.io/hotkeys\n * \n * Licensed under the MIT license.\n */\n\nvar isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件\n\nfunction addEvent(object, event, method) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, false);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), function () {\n      method(window.event);\n    });\n  }\n} // 修饰键转换成对应的键码\n\n\nfunction getMods(modifier, key) {\n  var mods = key.slice(0, key.length - 1);\n\n  for (var i = 0; i < mods.length; i++) {\n    mods[i] = modifier[mods[i].toLowerCase()];\n  }\n\n  return mods;\n} // 处理传的key字符串转换成数组\n\n\nfunction getKeys(key) {\n  if (typeof key !== 'string') key = '';\n  key = key.replace(/\\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等\n\n  var keys = key.split(','); // 同时设置多个快捷键，以','分割\n\n  var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理\n\n  for (; index >= 0;) {\n    keys[index - 1] += ',';\n    keys.splice(index, 1);\n    index = keys.lastIndexOf('');\n  }\n\n  return keys;\n} // 比较修饰键的数组\n\n\nfunction compareArray(a1, a2) {\n  var arr1 = a1.length >= a2.length ? a1 : a2;\n  var arr2 = a1.length >= a2.length ? a2 : a1;\n  var isIndex = true;\n\n  for (var i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n\n  return isIndex;\n}\n\nvar _keyMap = {\n  backspace: 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220\n}; // Modifier Keys\n\nvar _modifier = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  command: 91\n};\nvar modifierMap = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nvar _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nvar _handlers = {}; // F1~F12 special key\n\nfor (var k = 1; k < 20; k++) {\n  _keyMap[\"f\".concat(k)] = 111 + k;\n}\n\nvar _downKeys = []; // 记录摁下的绑定键\n\nvar _scope = 'all'; // 默认热键范围\n\nvar elementHasBindEvent = []; // 已绑定事件的节点记录\n// 返回键码\n\nvar code = function code(x) {\n  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\n}; // 设置获取当前范围（默认为'所有'）\n\n\nfunction setScope(scope) {\n  _scope = scope || 'all';\n} // 获取当前范围\n\n\nfunction getScope() {\n  return _scope || 'all';\n} // 获取摁下绑定键的键值\n\n\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n} // 表单控件控件判断 返回 Boolean\n// hotkey is effective only when filter return true\n\n\nfunction filter(event) {\n  var target = event.target || event.srcElement;\n  var tagName = target.tagName;\n  var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n\n  if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n    flag = false;\n  }\n\n  return flag;\n} // 判断摁下的键是否为某个键，返回true或者false\n\n\nfunction isPressed(keyCode) {\n  if (typeof keyCode === 'string') {\n    keyCode = code(keyCode); // 转换成键码\n  }\n\n  return _downKeys.indexOf(keyCode) !== -1;\n} // 循环删除handlers中的所有 scope(范围)\n\n\nfunction deleteScope(scope, newScope) {\n  var handlers;\n  var i; // 没有指定scope，获取scope\n\n  if (!scope) scope = getScope();\n\n  for (var key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n\n      for (i = 0; i < handlers.length;) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;\n      }\n    }\n  } // 如果scope被删除，将scope重置为all\n\n\n  if (getScope() === scope) setScope(newScope || 'all');\n} // 清除修饰键\n\n\nfunction clearModifier(event) {\n  var key = event.keyCode || event.which || event.charCode;\n\n  var i = _downKeys.indexOf(key); // 从列表中清除按压过的键\n\n\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题\n\n\n  if (event.key && event.key.toLowerCase() === 'meta') {\n    _downKeys.splice(0, _downKeys.length);\n  } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除\n\n\n  if (key === 93 || key === 224) key = 91;\n\n  if (key in _mods) {\n    _mods[key] = false; // 将修饰键重置为false\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = false;\n    }\n  }\n}\n\nfunction unbind(keysInfo) {\n  // unbind(), unbind all keys\n  if (!keysInfo) {\n    Object.keys(_handlers).forEach(function (key) {\n      return delete _handlers[key];\n    });\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach(function (info) {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === 'object') {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === 'string') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // support old method\n    // eslint-disable-line\n    var scope = args[0],\n        method = args[1];\n\n    if (typeof scope === 'function') {\n      method = scope;\n      scope = '';\n    }\n\n    eachUnbind({\n      key: keysInfo,\n      scope: scope,\n      method: method,\n      splitKey: '+'\n    });\n  }\n} // 解除绑定某个范围的快捷键\n\n\nvar eachUnbind = function eachUnbind(_ref) {\n  var key = _ref.key,\n      scope = _ref.scope,\n      method = _ref.method,\n      _ref$splitKey = _ref.splitKey,\n      splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;\n  var multipleKeys = getKeys(key);\n  multipleKeys.forEach(function (originKey) {\n    var unbindKeys = originKey.split(splitKey);\n    var len = unbindKeys.length;\n    var lastKey = unbindKeys[len - 1];\n    var keyCode = lastKey === '*' ? '*' : code(lastKey);\n    if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围\n\n    if (!scope) scope = getScope();\n    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    _handlers[keyCode] = _handlers[keyCode].map(function (record) {\n      // 通过函数判断，是否解除绑定，函数相等直接返回\n      var isMatchingMethod = method ? record.method === method : true;\n\n      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {\n        return {};\n      }\n\n      return record;\n    });\n  });\n}; // 对监听对应快捷键的回调函数进行处理\n\n\nfunction eventHandler(event, handler, scope) {\n  var modifiersMatch; // 看它是否在当前范围\n\n  if (handler.scope === scope || handler.scope === 'all') {\n    // 检查是否匹配修饰符（如果有返回true）\n    modifiersMatch = handler.mods.length > 0;\n\n    for (var y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    } // 调用处理程序，如果是修饰键不做处理\n\n\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if (event.cancelBubble) event.cancelBubble = true;\n      }\n    }\n  }\n} // 处理keydown事件\n\n\nfunction dispatch(event) {\n  var asterisk = _handlers['*'];\n  var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键\n\n  if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致\n  // Webkit左右 command 键值不一样\n\n  if (key === 93 || key === 224) key = 91;\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n\n  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {\n    var keyNum = modifierMap[keyName];\n\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {\n      /**\n       * Fix if Command is pressed:\n       * ===============================\n       */\n      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n      }\n    }\n  });\n  /**\n   * -------------------------------\n   */\n\n  if (key in _mods) {\n    _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = true;\n    }\n\n    if (!asterisk) return;\n  } // 将 modifierMap 里面的修饰键绑定到 event 中\n\n\n  for (var e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n\n\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n\n    _mods[17] = true;\n    _mods[18] = true;\n  } // 获取范围 默认为 `all`\n\n\n  var scope = getScope(); // 对任何快捷键都需要做的处理\n\n  if (asterisk) {\n    for (var i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n        eventHandler(event, asterisk[i], scope);\n      }\n    }\n  } // key 不在 _handlers 中返回\n\n\n  if (!(key in _handlers)) return;\n\n  for (var _i = 0; _i < _handlers[key].length; _i++) {\n    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {\n      if (_handlers[key][_i].key) {\n        var record = _handlers[key][_i];\n        var splitKey = record.splitKey;\n        var keyShortcut = record.key.split(splitKey);\n        var _downKeysCurrent = []; // 记录当前按键键值\n\n        for (var a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n\n        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n          // 找到处理内容\n          eventHandler(event, record, scope);\n        }\n      }\n    }\n  }\n} // 判断 element 是否已经绑定事件\n\n\nfunction isElementBind(element) {\n  return elementHasBindEvent.indexOf(element) > -1;\n}\n\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  var keys = getKeys(key); // 需要处理的快捷键列表\n\n  var mods = [];\n  var scope = 'all'; // scope默认为all，所有范围都有效\n\n  var element = document; // 快捷键事件绑定节点\n\n  var i = 0;\n  var keyup = false;\n  var keydown = true;\n  var splitKey = '+'; // 对为设定范围的判断\n\n  if (method === undefined && typeof option === 'function') {\n    method = option;\n  }\n\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    if (option.scope) scope = option.scope; // eslint-disable-line\n\n    if (option.element) element = option.element; // eslint-disable-line\n\n    if (option.keyup) keyup = option.keyup; // eslint-disable-line\n\n    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line\n\n    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line\n  }\n\n  if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理\n\n  for (; i < keys.length; i++) {\n    key = keys[i].split(splitKey); // 按键列表\n\n    mods = []; // 如果是组合快捷键取得组合快捷键\n\n    if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码\n\n    key = key[key.length - 1];\n    key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键\n    // 判断key是否在_handlers中，不在就赋一个空数组\n\n    if (!(key in _handlers)) _handlers[key] = [];\n\n    _handlers[key].push({\n      keyup: keyup,\n      keydown: keydown,\n      scope: scope,\n      mods: mods,\n      shortcut: keys[i],\n      method: method,\n      key: keys[i],\n      splitKey: splitKey\n    });\n  } // 在全局document上设置快捷键\n\n\n  if (typeof element !== 'undefined' && !isElementBind(element) && window) {\n    elementHasBindEvent.push(element);\n    addEvent(element, 'keydown', function (e) {\n      dispatch(e);\n    });\n    addEvent(window, 'focus', function () {\n      _downKeys = [];\n    });\n    addEvent(element, 'keyup', function (e) {\n      dispatch(e);\n      clearModifier(e);\n    });\n  }\n}\n\nvar _api = {\n  setScope: setScope,\n  getScope: getScope,\n  deleteScope: deleteScope,\n  getPressedKeyCodes: getPressedKeyCodes,\n  isPressed: isPressed,\n  filter: filter,\n  unbind: unbind\n};\n\nfor (var a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    hotkeys[a] = _api[a];\n  }\n}\n\nif (typeof window !== 'undefined') {\n  var _hotkeys = window.hotkeys;\n\n  hotkeys.noConflict = function (deep) {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n\n    return hotkeys;\n  };\n\n  window.hotkeys = hotkeys;\n}\n\nexport default hotkeys;\n","import hotkeys from 'hotkeys-js';\n\nexport function menuButton(): Element {\n    let node = document.createElement('div');\n    node.innerHTML = 'Press <b>/</b> for help';\n    node.classList.add('border', 'hover:border-gray-800');\n    node.classList.add('card', 'text-center');\n\n    document.body.append(menuModal());\n    node.onclick = toggleMenu;\n    return node;\n}\n\nfunction toggleMenu() {\n    let element = document.getElementById('menu');\n    element.hidden = !element.hidden;\n}\n\nfunction menuModal(): Element {\n    let heading = document.createElement('div');\n    heading.classList.add('card-heading');\n    heading.textContent = 'Menu';\n\n    let node = document.createElement('div');\n    node.classList.add('modal');\n    node.hidden = true;\n    node.id = 'menu';\n    node.append(heading);\n    menuItems(node);\n\n    let container = document.createElement('div');\n    container.classList.add('modal-container');\n    container.append(node);\n    return container;\n}\n\nfunction menuItems(node: Element) {\n    node.append(menuItem('Open Problem', () =>\n        window.location.href = 'index.html', 'O'));\n    node.append(menuItem('Authenticate', () =>\n        window.location.href = 'authenticate.html'));\n    node.append(menuItem('Clear caches', () =>\n        localStorage.clear()));\n    node.append(menuItem('Help', toggleMenu, '/'));\n}\n\nfunction menuItem(label: string, run: () => void, bind?: string): Element {\n    let item = document.createElement('div');\n    item.classList.add('item');\n    if (bind != undefined) {\n        hotkeys(bind, () => run());\n        item.innerHTML = `<b>${bind}</b> - `;\n    }\n\n    item.innerHTML += label;\n    item.onclick = () => {\n        toggleMenu();\n        run();\n    };\n\n    return item;\n}\n","/**\n * Fuse.js v6.4.6 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2021 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      totalWeight += obj.weight;\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n  }\n\n  return { path, id, weight, src }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      const norm = 1 / Math.sqrt(numTokens);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({ getFn = Config.getFn } = {}) {\n    this.norm = norm(3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      // console.log(key)\n      let value = this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          }\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (!isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(keys, docs, { getFn = Config.getFn } = {}) {\n  const myIndex = new FuseIndex({ getFn });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(data, { getFn = Config.getFn } = {}) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// ❗Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore$1(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore$1(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      /*eslint indent: [2, 2, {\"SwitchCase\": 1}]*/\n      switch (node.operator) {\n        case LogicalOperator.AND: {\n          const res = [];\n          for (let i = 0, len = node.children.length; i < len; i += 1) {\n            const child = node.children[i];\n            const result = evaluate(child, item, idx);\n            if (result.length) {\n              res.push(...result);\n            } else {\n              return []\n            }\n          }\n          return res\n        }\n        case LogicalOperator.OR: {\n          const res = [];\n          for (let i = 0, len = node.children.length; i < len; i += 1) {\n            const child = node.children[i];\n            const result = evaluate(child, item, idx);\n            if (result.length) {\n              res.push(...result);\n              break\n            }\n          }\n          return res\n        }\n      }\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '6.4.6';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport default Fuse;\n","import {DOMAIN_ROOT, fetchPage, sessionIdentifier} from './tunnel';\nimport {template} from './other';\nimport {menuButton} from './menu';\nimport Fuse from 'fuse.js';\n\nclass Group {\n    link: string;\n    name: string;\n}\n\ninterface ProblemStub {\n    item: ProblemItem;\n    group: Group;\n    set: string;\n}\n\ninterface ProblemItem {\n    link: string;\n    name: string;\n    score?: string;\n}\n\nlet groups = document.getElementById('groups');\nlet searchBox = document.getElementById('search') as HTMLInputElement;\nlet problems = document.getElementById('problems');\n\nlet fuseGroups = new Fuse([], {\n    keys: ['link', 'name'],\n    minMatchCharLength: 3,\n    threshold: 0.1,\n})\n\nlet fuse = new Fuse([], {\n    minMatchCharLength: 3,\n    threshold: 0.1,\n    keys: [\n        'item.link',\n        'item.name',\n        'group.name',\n        'set',\n    ],\n});\n\nasync function index() {\n    let page = await fetchPage(DOMAIN_ROOT);\n    let main = page.getElementById('main-container');\n    let container = main.firstElementChild;\n\n    // Load public problems.\n    let open = container.lastElementChild.lastElementChild;\n    let link = 'https://train.nzoi.org.nz/groups/0';\n    let openGroup = {name: 'Public Problems', link};\n    cacheGroup(openGroup, problemStubs(open, openGroup));\n    registerGroup(openGroup).catch(console.error);\n\n    if (container.children.length == 2) {\n        loadGroups(container.firstElementChild);\n    } else {\n        let element = (sessionIdentifier() != undefined ?\n            document.getElementById('invalid-session-alert') :\n            document.getElementById('no-session-alert'));\n        element.hidden = false;\n    }\n\n    let end = document.getElementById('content-end');\n    end.append(menuButton());\n}\n\nfunction loadGroups(column: Element) {\n    let heading = column.firstElementChild;\n    let element = heading.nextElementSibling;\n    while (element != null) {\n        let anchor = element.querySelector('a');\n        let link = DOMAIN_ROOT + anchor.getAttribute('href');\n        let group = {link, name: anchor.textContent};\n        registerGroup(group).catch(console.error);\n        element = element.nextElementSibling;\n    }\n}\n\nfunction groupSelector(group: Group): Element {\n    let node = template(document.getElementById('group'));\n    let selector = node.querySelector('#group-select') as HTMLElement;\n\n    selector.onclick = () => {\n        setSearchBoxValue(group.name);\n        populateGroup(group, true).catch(console.error);\n    };\n\n    selector.id = group.link;\n    selector.textContent = group.name;\n    return node;\n}\n\nasync function registerGroup(group: Group) {\n    groups.append(groupSelector(group));\n    await populateGroup(group, false);\n    fuseGroups.add(group);\n    renderGroups();\n}\n\nasync function populateGroup(group: Group, refresh: boolean) {\n    let element = document.getElementById(group.link);\n    element.classList.add('animate-pulse');\n\n    if (localStorage.getItem(group.link) == null || refresh)\n        await indexGroup(group);\n\n    let stubs = JSON.parse(localStorage.getItem(group.link));\n    fuse.remove((stub) => stub.group.link == group.link);\n    stubs.forEach((stub) => fuse.add(stub));\n\n    // Render with updated problem indexes.\n    element.classList.remove('animate-pulse');\n    renderUniqueItems();\n}\n\nfunction cacheGroup(group: Group, stubs: ProblemStub[]) {\n    localStorage.setItem(group.link, JSON.stringify(stubs));\n}\n\nasync function indexGroup(group: Group) {\n    let page = await fetchPage(group.link);\n    let table = page.querySelector('.main_table');\n    cacheGroup(group, problemStubs(table, group));\n}\n\nfunction problemStubs(table: Element, group: Group): ProblemStub[] {\n    let body = table.querySelector('tbody');\n    let headings = body.querySelectorAll('.subheading');\n    return Array.from(headings, ((itemSet) => {\n        let set = itemSet.firstElementChild.firstChild.textContent;\n        let setTable = itemSet.nextElementSibling.querySelector('tbody');\n        return Array.from(setTable.children, (problem) => {\n            let anchor = problem.querySelector('a');\n            let link = DOMAIN_ROOT + anchor.getAttribute('href');\n            let name = anchor.textContent;\n\n            let progress = problem.children[1].firstElementChild;\n            let score = progress.lastChild.textContent;\n            return {item: {link, name, score}, set, group};\n        });\n    })).flat();\n}\n\nfunction filter<T>(fuse: Fuse<T>): T[] {\n    return searchBox.value.length != 0 ?\n        fuse.search(searchBox.value).map((item) => item.item)\n        : (fuse as any)._docs;\n}\n\nfunction render() {\n    renderGroups();\n    renderUniqueItems();\n}\n\nfunction renderGroups() {\n    let groupItems = filter(fuseGroups);\n    let container = groups.parentElement;\n    container.hidden = groupItems.length === 0;\n\n    for (let group of groups.children)\n        group.classList.add('hidden');\n    groupItems.forEach((group) => {\n        let node = document.getElementById(group.link);\n        node.classList.remove('hidden');\n    });\n}\n\nfunction renderUniqueItems() {\n    let links = new Set();\n    let items = filter(fuse).map((item) => item.item);\n    problems.innerHTML = '';\n\n    let query = searchBox.value;\n    if (query.startsWith(DOMAIN_ROOT + '/problems'))\n        renderItem({name: query, link: query});\n\n    items.forEach((item) => {\n        if (links.has(item.link)) return;\n        links.add(item.link);\n        renderItem(item);\n    });\n\n    let container = problems.parentElement;\n    container.hidden = problems.innerHTML == '';\n}\n\nfunction renderItem(item: ProblemItem) {\n    let node = template(document.getElementById('problem'));\n    node.querySelector('#problem-name').textContent = item.name;\n    let link = node.querySelector('#problem-link') as HTMLAnchorElement;\n    link.href = `render.html?link=${item.link}`;\n\n    let score = node.querySelector('#problem-score');\n    score.textContent = (item.score || '').toString();\n    problems.append(node);\n}\n\nfunction setSearchBoxValue(value: string) {\n    searchBox.value = value;\n    render();\n}\n\nsearchBox.oninput = render;\nindex().finally(() => {\n    let loader = document.getElementById('loader');\n    loader.classList.add('hidden');\n});\n"]}